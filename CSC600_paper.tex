\documentclass[10pt,conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{balance}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage[mathscr]{euscript}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{amsmath,amssymb}
\usepackage[usenames, dvipsnames]{color}
\usepackage{wrapfig}
\usepackage{cite}
\usepackage{float}
\usepackage[flushleft]{threeparttable}
\usepackage{pifont}
\usepackage{scrextend}
\usepackage{soul}
\usepackage{color} 
\usepackage{fancyvrb}
\usepackage{hyperref}
\usepackage{lettrine}
\usepackage[T1]{fontenc}


\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Preconditions on Rename Refactorings}

\author{
\IEEEauthorblockN{Soumya Mudiyappa}
\IEEEauthorblockA{\textit{West Chester University}\\fs926226@wcupa.edu}
\and
\IEEEauthorblockN{Swetchha Shukla}
\IEEEauthorblockA{\textit{West Chester University}\\ss928947@wcupa.edu}
\and
\IEEEauthorblockN{Yung-Chen Cheng}
\IEEEauthorblockA{\textit{West Chester University}\\yc917559@wcupa.edu}
}

\maketitle

\begin{abstract}
In computer programming and software design, \emph{refactoring} is the process of restructuring existing code by changing the factoring without changing its external behavior. Refactoring is intended to improve the design, structure, and implementation of the software, while preserving its functionality. In simple words, refactoring is a \emph{behavior preserving} code transformation technique, for example- rename, move, extract etc. Refactoring rely on two important factors - \emph{precondition checks and code changes}. In this paper, we explain about the rename refactoring and the preconditions in detail for each type of rename refactorings.
\end{abstract}

\section{\textbf{Introduction}}
\lettrine{R}{efactoring} is a controlled technique for improving the design of an existing code base. Its essence is applying a series of small behavior-preserving transformations, each of which ``too small to be worth doing''. However the cumulative effect of each of these transformations is quite significant. By doing them in small steps we reduce the risk of introducing errors. We also avoid having the system broken while carrying out the restructuring - which allows us to gradually refactor a system over an extended period of time.~\cite{Fowler}

The idea behind refactoring were introduced over decades ago, but scripting of refactorings is poorly suppported by current IDEs tools. Todayâ€™s IDEs lack fine-grained primitive refactorings including restrictive/imprecise preconditions and inconsistent code transformations. There are further more challenges for executing refactoring as it is error-prone, timeconsuming and laborious work. Scripting refactoring with current IDEs are too slow because precondition checks and AST operation takes largest time which makes scripting refactorings impractical. Therefore, we need tools that automate refactorings scripts with precise preconditions, high speed and reliability and which we may reuse frequently. 

\section{\textbf{Rename Refactorings}}
Rename Refactoring changes the name of identifiers in a program without changing the program's behavior.
There are five types of Rename Refactoring in Java and each of them have different preconditions. 
\begin{enumerate}
	\item Rename Class Declarations 
	\item Rename Method Declarations  
	\item Rename Field Variables
	\item Rename Local Variables 
	\item Rename Package Declarations
\end{enumerate}

\section{\textbf{Preconditions of Rename Class Refactoring}}
Rename Class Refactoring (RcR) changes the name of the class and all references to that class to the new name without changing its behavior. There are certain preconditions required for RcR. 
\begin{enumerate}
	\item The target class cannot be duplicate with any existing class within same package after rename.
	\item The target class cannot be duplicate with any imported class from different package after rename.
	\item The target class name cannot be duplicate with any existing java file name within same package after rename.
\end{enumerate}

\input{Precon1}\label{sec:precon1}
	
\input{Precon2}\label{sec:precon2}

\input{Precon3}\label{sec:precon3}

\input{Method}

\input{Field}

\input{Local}

\input{Package}

\section{\textbf{Conclusion}}
Refactoring is about improving the design of existing code. It is the process of simplifying the design in such a way that it does not alter the external behavior of the code, yet improves its internal structure. The main goal of refactoring is to have reduced complexity, improved performance and code readability, while preserving its functionality. Refactoring rely on two important factors -  \emph{precondition checks and code changes}.

Though refactoring was introduced decades ago, there is no standard preconditions set for all the IDEs. All IDEs such as Eclipse, IntelliJ etc follow imprecise preconditions and inconsistent code transformations which fails to preserve the behavior of the code. There are many challenges for executing refactoring as it is prone to error and time-consuming. 

With the objective of simplifying development of all refactoring tools, refactoring functionality of different IDEs has been examined in order to find opportunities to simplify the design of the existing code. This document explains the preconditions about rename refactoring of Class, Method, Field, Local Variable and Package in detail with examples which gives a clear picture of the importance of refactoring. 

In the world of Computer programming and software design, refactoring developers are in need of tools which are capable of having automated refactoring scripts with precise preconditions, high speed and reliability, which we may be reused frequently. Therefore, it is concluded that regular updates and documentation of precondition checks will ease the implementation of Refactoring tools for all the IDEs.

\bibliographystyle{IEEEtran}
\bibliography{ref}

\end{document}
