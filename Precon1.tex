\subsection{The target class cannot be duplicate with any existing class within same package after rename.}

When we rename a class with any existing class name, the Java compiler produces error message about duplicate class name. The classes will be conflicted if we run rename refactor on the target class using the name of an existing class in the same package. So, we can not have duplicate class names in the same package. 

For example, if we run rename refactor on the class name from \textsl{A} to \textsl{B} as in Fig. \ref{fig:afterrr}, then the compiler produces an error message: \textit{``duplicate class: p.B"}.

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
package p;

class A{
}
	
class B{
}

class C{
}
 
\end{lstlisting}
\centering{(a) Before}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
package p;

class B{
}	

class B{
}

class C{
}

\end{lstlisting}
\centering{(b) After}
\end{minipage}
\caption{\textbf{Example of RcR from A to B}}
\label{fig:afterrr}
\end{figure}


Furthermore, the same situation occurs in nested classes. The examples below show that for RcR we can not use the same name either as inner or as outer class for nested classes like Fig. \ref{fig:original}.

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.5\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
package p;

public class A{	

  class M{
  }

  class N{
  }
} 
\end{lstlisting}
\end{minipage}
\caption{\textbf{Nested Class before RcR}}
\label{fig:original}
\end{figure}

\textbf{Example 1:} In order to apply RcR for inner class, we should pre-check that we do not use the same name as any of other inner class name. As shown in Fig. \ref{fig:nestedclass1}, when we run RcR on the inner class from M to N, the Java compiler produces an error as shown in Fig. \ref{fig:NC1}.

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.5\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
package p;

public class A{	
    
  class N{
  }
    
  class N{
  }
} 
\end{lstlisting}
\end{minipage}
\caption{\textbf{Example 1 for Nested Class after RcR from M to N}}
\label{fig:nestedclass1}
\end{figure}

\textbf{Example 2:} In order to apply RcR for outer class, we should pre-check that we do not use the same name as any of the inner class name and vice-versa. As shown in Fig. \ref{fig:nestedclass2}, when we use same name for outer class and inner class, the Java compiler produces an error as shown in Fig. \ref{fig:NC2} and Fig. \ref{fig:NC3}.

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
package p;

public class M{	
  
  class M{
  }
	
  class N{
  }
} 
\end{lstlisting}
\centering{(a) After RcR on Outer Class A to M}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
package p;

public class A{	
    
  class M{
  }
    
  class A{
  }
} 
\end{lstlisting}
\centering{(b) After RcR on Inner Class N to A}
\end{minipage}
\caption{\textbf{Example 2 of Nested Class after RcR}}
\label{fig:nestedclass2}
\end{figure}

Therefore, checking whether a class with the same name already exists in a package should be the first precondition for RcR. 
   
