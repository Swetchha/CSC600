\section{\textbf{Preconditions of Rename Field Refactoring}}
Rename Field Refactoring(RfR) changes the declaration and usages of the field to the new name without changing its behavior.
Fields are the variables of a class i.e. instance variables and static variables.
There are certain preconditions required for RfR.

\begin{enumerate}
	\item The target name of field cannot be duplicate with any existing field within same class after rename.
	\item The target name of field cannot be duplicate with any local variable within same method after rename.
\end{enumerate}

\subsection{The target name of field cannot be duplicate with any existing field within same class after rename.}

In order to apply RfR on field, we have to pre-check that the new name of the field is not duplicate with any existing field name of any data type within same class. As shown in Fig. \ref{figure:field}(b), when we apply RfR from \emph{`j' to `i'}, Java compiler produces an error \textit{``variable i is already defined in class A''}. This is because of the conflict for duplicate field declaration for same type variable. As shown in Fig. \ref{figure:field}(c), when we apply RfR from \emph{`s' to `i'}, Java compiler produces an error \textit{``variable i is already defined in class A''}. This is because the compiler will not be able to distinguish between different type variables \emph{`String i'} and \emph{`int i'}.

\begin{figure}[th]
\centering	
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

   int i = 0;
   int j = 2;
   String s = "hi";
}

\end{lstlisting}
\centering(a) Before RfR
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

   int i = 0;
   int i = 2;
   String i = "hi";
}
\end{lstlisting}
\centering(b) After RfR from j to i
\end{minipage}

\centering
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

   int i = 0;
   int j = 2;
   String i = "hi";
}
\end{lstlisting}
\centering(c) After RfR from s to i
\end{minipage}
\caption{\textbf{RfR on field variables}}
\label{figure:field}
\end{figure}


\subsection{The target name of field cannot be duplicate with any local variable within same method after rename.}
In order to apply RfR on field, we have to pre-check that the new name of field is not duplicate with any local variable name, if field is being used in the same block as local variable. 

As shown in Fig. \ref{figure:sameBlock}(a), on executing the output is `0'. However,  after we apply RfR from \emph{`x' to `y'} and on executing Fig. \ref{figure:sameBlock}(b), the output is `5'. Although the compiler did not produce any error but the behavior of code has changed since the output on RfR got changed. This is because if a field variable and a local variable have the same name, then the local variable will be accessed. This process effectively shadows the field variable and therefore known as \textit{Variable Shadowing}. 
 

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A{

   int x = 0;
   void m(int y){
      System.out.print(x);
   }
	
   void main(String[] args){
      A.m(5);
   }
}

\end{lstlisting}
\centering(a) Before
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A{

   int y = 0;
   void m(int y){
      System.out.print(y);
   }
	
   void main(String[] args){
      A.m(5);
   }
}\end{lstlisting}
\centering(b) After
\end{minipage}
\caption{\textbf{RfR from x to y}}
\label{figure:sameBlock}
\end{figure}

The same concept is applied to class hierarchies. A field variable declared within a parent class will be shadowed by any variable with the same name in a child class. As shown in Fig. \ref{figure:beforeRfR}, on executing the output it `0'. However, after we apply RfR on field variable of a child class from j to i and on executing the program in Fig. \ref{figure:afterRfR}, the output is `1'. 

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.75\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

   int i = 0;
}

class B extends A {

   int j = 1; 
}

public class C {
   public static void main(String[] args){

      B b = new B();
      System.out.println(b.i);
   }
}
\end{lstlisting}
\end{minipage}
\caption{\textbf{Before RfR on child class field variable j}}
\label{figure:beforeRfR}
\end{figure}

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.75\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

   int i = 0;
}

class B extends A {

   int i = 1; 
}

public class C {
   public static void main(String[] args){

      B b = new B();
      System.out.println(b.i);
   }
}
\end{lstlisting}
\end{minipage}
\caption{\textbf{After RfR on child class field variable j to i}}
\label{figure:afterRfR}
\end{figure}

Therefore, it is essential to pre-check that the new name of field is not duplicate with any existing local variable if both are used in same block or in parent and child classes. 