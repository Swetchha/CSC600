\section{\textbf{Preconditions of Rename Method Refactoring}}

Rename Method Refactoring (RmR) changes the name of the method and all references to that method to the new name without changing its functionality in the program.

There are three types of Rename Method Refactorings:
\begin{enumerate}
\item Rename Static Method Declarations.
\item Rename Non-static Method Declarations.
\item Rename Constructor Method Declarations.
\end{enumerate}

There are certain preconditions required for RmR which are applicable to each type of RmR.
\begin{enumerate}
	\item The target method cannot be a duplicate of an existing method after rename.
	\item A duplicate method in a child class cannot have different return type.
	\item A duplicate method in a child class cannot reduce visibility.
\end{enumerate}

\subsection {The target method cannot be duplicate of an existing method after rename. }

If two or more methods have same method signature with
below conditions, those methods will be called as duplicate
methods.
\begin{itemize}
	\item Same method name
	\item Same number of parameters
	\item Same parameter types in order
\end{itemize}

From Fig. \ref{fig:RmR}, when we apply RmR from m to n, the compiler produces an error ``\textsl{method n() is already defined in class A}''. This is because another duplicate method already exists in the class. Hence, we have to check the target method name can not be the same as the existing method.

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m(int a) {	
  }

  void n(int b) {	
  }	
}
 
\end{lstlisting}
\centering{(a) Before}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void n(int a) {	
  }

  void n(int b) {	
  }	
}

\end{lstlisting}
\centering{(b) After}
\end{minipage}
\caption{\textbf{Rename Refactoring Method m to n}}
\label{fig:RmR}
\end{figure}

To further define the duplicate methods, some of the use-cases are as follows:

\subsubsection {Duplicate Methods with convertible Input parameters}

From Fig. \ref{fig:RmR4}, method m1 has input parameter type as `int' and m2 has input parameter type as `double'. When we call method m2 with int data type as the parameter, int automatically and implicitly type-casted by java compiler into double and outputs `bye' as shown in Fig. \ref{fig:RmR4}(a). 

When we apply RmR from m2 to m1 and call method m1 by passing `int' as input parameter then the output is `hello' as shown in Fig. \ref{fig:RmR4}(b). Here, it is clearly evident that after RmR, the original output has changed even with pre-checking condition for duplicate method. 	
This implies that the definition for duplicate method is not enough to rely on and we need to revise duplicate methods to prevent these ambiguity.

Below are primitive type coercions (i.e., implicit type conversions).  Java allows to convert primitive types without losing information about a numeric value. 
\textbf{
\begin{center}
byte < short < int < float < double
\end{center}
}

When the duplicate methods have the larger type size and smaller type is passed then it can be converted to larger type size. The revised definition is that the duplicate methods can have the different data type but the property of widening or automatic type conversion has to be taken care of.

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.47\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m1(int i) {	
    System.out.print("hi");
  }

  void m2(double j) {	
     System.out.print("bye");
  }	
  
  void main(String[] args){
	
     // output: bye
     this.m2(100); 
  }
}
 
\end{lstlisting}
\centering{(a) Before}
\end{minipage}
\hfill
\begin{minipage}[t]{0.47\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m1(int i) {	
    System.out.print("hi");
  }

  void m1(double j) {	
     System.out.print("bye");
  }	
  
  void main(String[] args){
	
     // output: hi
     this.m1(100); 
  }
}

\end{lstlisting}
\centering{(b) After}
\end{minipage}
\caption{\textbf{Rename Refactoring Method m2 to m1}}
\label{fig:RmR4}
\end{figure}

\subsubsection {Non-Duplicate methods Ambiguity} 
From Fig. \ref{fig:RmR5}(a), methods m1 and m2 are non-duplicate methods and the output is `hi'. However, when we apply RmR from m2 to m1 as shown in Fig. \ref{fig:RmR5}(b), the compiler produces an error \textsl{``reference to m1 is ambiguous as both method m1(String,float) in A and method m1(Object,int) in A match''}. 

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.48\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A{

  void m1(String s, float d){
	
      // output: hello
      System.out.print(s); 
   }

  void m2(Object o, int i){
      System.out.print(o);
   }

  void main(String[] args){
      this.m1("hi", 1);
   }
}
\end{lstlisting}
\centering{(a) Before }
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A{

  void m1(String s, float d){
	
      // Error
      System.out.print(s); 
   }

  void m1(Object o, int i){
      System.out.print(o);
   }

  void main(String[] args){
      this.m1("hi", 1);
   }
}

\end{lstlisting}
\centering{(b) After }
\end{minipage}
\caption{\textbf{Rename Refactoring Method m2 to m1}}
\label{fig:RmR5}
\end{figure}

Hence, it is essential to pre-check that the non-duplicate methods on RmR does not result in argument ambiguity.

\subsection{A duplicate method in a child class cannot have different return type.}

If a duplicate method exists in both parent and child class, Java does not allow these duplicate methods to have different return types.

In Fig. \ref{fig:RmR2} (b), when we apply RmR from B.m2() to B.m1(), compiler produces an error \textsl{`` m1() in B cannot override m1() in A as return type int is not compatible with void''}. This is because the duplicate method m1 have different return types which is not allowed. 

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.47\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m1() {
    System.out.print("hi");
  }
}
class B extends A{
 
  int m2() {
    System.out.print("bye");
  }	
}
 
\end{lstlisting}
\centering{(a) Before}
\end{minipage}
\hfill
\begin{minipage}[t]{0.47\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m1() {
    System.out.print ("hi");
  }
}
class B extends A{
 
  int m1() {
    System.out.print ("bye");
  }	
}

\end{lstlisting}
\centering{(b) After}
\end{minipage}
\caption{\textbf{Rename Refactoring Method m2 to m1}}
\label{fig:RmR2}
\end{figure}

\subsection{A duplicate method in a child class cannot reduce visibility.}

The use of access modifiers helps with visible duplicate methods, however there is a proper hierarchy for access modifiers to be followed for duplicate methods.


\begin{center}
\textbf{public $>$ protected $>$ package-public $>$ private}
\end{center}


As shown in \ref{fig:RmR3}(b), the package-public visibility gets reduced to private for duplicate methods m1() and compiler produces an error \textsl{``m1() in B cannot override m1() in A as attempting to assign weaker access privileges; was package''}. 

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.47\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m1() {
    System.out.print ("hi");
  }
}
class B extends A{

  private void m2() {
    System.out.print ("bye");
  }	
}
 
\end{lstlisting}
\centering{(a) Before }
\end{minipage}
\hfill
\begin{minipage}[t]{0.47\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m1() {
    System.out.print ("hi");
  }
}
class B extends A{
 
  private void m1() {
    System.out.print ("bye");
  }	
}

\end{lstlisting}
\centering{(b) After }
\end{minipage}
\caption{\textbf{Rename Refactoring Method m2 to m1}}
\label{fig:RmR3}
\end{figure}

Therefore, it is essential to pre-check that new name of method does not result in visibility reduction. 