\section{\textbf{Preconditions of Rename Method Refactoring}}

Rename Method Refactoring (RmR) changes the name of the method and all references to that method to the new name without changing its functionality in the program.

There are three types of Rename Method Refactorings:
\begin{enumerate}
\item Rename Static Method Declarations.
\item Rename Non-static Method Declarations.
\item Rename Constructor Method Declarations.
\end{enumerate}

There are certain preconditions required for RmR which are applicable to each type of RmR.
\begin{enumerate}
	\item The target method cannot be a duplicate of an existing method after rename.
	\item A duplicate method in a child class cannot have different return type.
	\item A duplicate method in a child class cannot reduce visibility.
\end{enumerate}

\subsection {The target method cannot be duplicate of an existing method after rename. }

From Fig. \ref{fig:RmR}, we have method \textsl{m} and method \textsl{n} with same input parameters but different method names. If we do RmR for m to n, the compiler will show the error: \textsl{method n() is already defined in class A.} The behavior of the code does not remain the same after doing RmR. Hence, we have to check the target method name can not be the same as the existing method.

If we use the same name of an existing method for RmR like Fig. \ref{fig:RmR}, the compiler will show the error: \textsl{method n() is already defined in class A.}

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m(int a) {	
  }

  void n(int b) {	
  }	
}
 
\end{lstlisting}
\centering{(a) Before RmR}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void n(int a) {	
  }

  void n(int b) {	
  }	
}

\end{lstlisting}
\centering{(b) After RmR}
\end{minipage}
\caption{\textbf{Example of RmR}}
\label{fig:RmR}
\end{figure}

To understand the above precondition, we should know what exactly is duplicate method.

By Definition of duplicate method, there are following properties:
1) The method should have same name.
2) Same Parameter types in order
3) Same number of function parameters

To derive the definition of Duplicate methods, there are certain use-cases to be considered. Some of them are as follows:

\subsubsection.{Duplicate Methods with convertible Input parameters / Argument ambiguity.}

From Fig. \ref{fig:RmR4},we have 2 methods m1 and m2 , m1 has input parameter `int' and m2 has input parameter `double', if we call m2 with integer as the input, m2 internally typecasts the passed integer into double and displays the output bye as shown in Fig. \ref{fig:RmR4}(a). If we RmR m2 to m1 and then pass integer as input then the output will be ”hello” as shown in Fig. \ref{fig:RmR4}(b).

In Java we have type conversion of a smaller type to a larger type size automatically.

byte < short < char < int < float < double

When the duplicate functions has the larger type size and smaller type is passed then it automatically gets converted to larger type size.The revised rule should be that Duplicate functions can have the different datatype but the property of Widening or Automatic Type Conversion has to be taken care of.

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.8\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m1(int i) {	
    System.out.println("hello");
  }

  void m2(double i) {	
     System.out.println("bye");
  }	
  
  public static void main(String[] args){
     A a = new A();
     a.m2(100); // outputs bye
  }
}
 
\end{lstlisting}
\centering{(a) Before RmR}
\end{minipage}
\hfill
\begin{minipage}[t]{0.8\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m1(int i) {	
    System.out.println("hello");
  }

  void m1(double i) {	
     System.out.println("bye");
  }	
  
  public static void main(String[] args){
     A a = new A();
     a.m1(100); // outputs hello
  }
}

\end{lstlisting}
\centering{(b) After RmR}
\end{minipage}
\caption{\textbf{Duplicate Methods with convertible input parameter}}
\label{fig:RmR4}
\end{figure}

\subsubsection.{Duplicate Methods with input parameters of same parent Class}

From Fig. \ref{fig:RmR5}, we have 3 classes , Class A, Class B and Class C. Class C has methods m1 and m2 with input parameters of type Class A and B. If we call new C().m1(new B()), it displays the output as ``hello''. After RmR m1 to m2 and calling new C().m2(new B()) will display the output as bye. In both the methods we are calling input parameter of type class which is associated with same parent class A and the behavior of the output is different. 
The revised rule should be that duplicate functions can have the parameters of type ‘class’ but it should not be associated with the same parent class.

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.8\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
public class A {
}

class B extends A {
}

class C {

   void m1(A a) {
      System.out.println("hello");
   }

   void m2(B b) {
      System.out.println("Bye");
   }
}
public class Main {

   public static void main(String[] args) {

      new C().m1(new B()); //outputs hello

   }
}
\end{lstlisting}
\centering{(a) Before RmR}
\end{minipage}
\hfill
\begin{minipage}[t]{0.8\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
public class A {
}

class B extends A {
}

class C {

   void m2(A a) {
      System.out.println("hello");
   }

   void m2(B b) {
      System.out.println("Bye");
   }
}
public class Main {

   public static void main(String[] args) {

      new C().m2(new B()); //outputs bye

   }
}

\end{lstlisting}
\centering{(b) After RmR}
\end{minipage}
\caption{\textbf{Duplicate Methods with input parameters of same parent Class}}
\label{fig:RmR5}
\end{figure}

\subsection{A duplicate method in a child class cannot have different return type.}

Java does not allow methods with the same signature to have different return types.

In Fig. \ref{fig:RmR2} (a), A.m1() and B.m2() are two non-duplicate methods which can be rename refactored. However, in Fig. \ref{fig:RmR2} (b), after doing RmR from B.m2() to B.m1(), we get compile-error because the duplicate method m1 have different return types which is not allowed. Thus, we need to check this precondition before doing RmR to avoid compile errors.

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.7\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m1() {
    System.out.print ("Hello");
  }
}
class B extends A{
 
  int m2() {
    System.out.print ("Bye");
  }	
}
 
\end{lstlisting}
\centering{(a) Before RmR}
\end{minipage}
\hfill
\begin{minipage}[t]{0.7\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
cclass A {

  void m1() {
    System.out.print ("Hello");
  }
}
class B extends A{
 
  int m1() {
    System.out.print ("Bye");
  }	
}

\end{lstlisting}
\centering{(b) After RmR}
\end{minipage}
\caption{\textbf{Duplicate methods with different return types}}
\label{fig:RmR2}
\end{figure}

\subsection{A duplicate method in a child class cannot reduce visibility.}

The use of access modifiers helps with visible duplicate methods, however, there is a proper hierarchy for access modifiers to be followed for duplicate methods.

\textbf{public} > \textbf{protected} > \textbf{package-public} > \textbf{private}

As shown in \ref{fig:RmR3} (b), the package-public visibility can not be reduced to private for duplicate methods m1(). We also need to check this precondition before doing RmR to the duplicate methods.

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.7\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m1() {
    System.out.print ("Hello");
  }
}
class B extends A{

  private void m2() {
    System.out.print ("Bye");
  }	
}
 
\end{lstlisting}
\centering{(a) Before RmR}
\end{minipage}
\hfill
\begin{minipage}[t]{0.7\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
cclass A {

  void m1() {
    System.out.print ("Hello");
  }
}
class B extends A{
 
  private void m1() {
    System.out.print ("Bye");
  }	
}

\end{lstlisting}
\centering{(b) After RmR}
\end{minipage}
\caption{\textbf{Duplicate methods with reduced visibility}}
\label{fig:RmR3}
\end{figure}