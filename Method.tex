\section{\textbf{Preconditions of Rename Method Refactoring}}

Rename Method Refactoring (RmR) changes the name of the method and all references to that method to the new name without changing its functionality in the program.

There are three types of Rename Method Refactorings:
\begin{enumerate}
\item Rename Static Method Declarations.
\item Rename Non-static Method Declarations.
\item Rename Constructor Method Declarations.
\end{enumerate}

There are certain preconditions required for RmR which are applicable to each type of RmR.
\begin{enumerate}
	\item The target method cannot be a duplicate of an existing method after rename.
	\item A duplicate method in a child class cannot have different return type.
	\item A duplicate method in a child class cannot reduce visibility.
\end{enumerate}

\subsection {The target method cannot be duplicate of an existing method after rename. }

If two or more methods have same method signature with
below conditions, those methods will be called as duplicate
methods.
\begin{itemize}
	\item Same method name
	\item Same parameter types in order
	\item Same number of parameters
\end{itemize}

From Fig. \ref{fig:RmR}, when we apply RmR from m to n, the compiler produces an error ``\textsl{method n() is already defined in class A}''. This is because another duplicate method already exists in the class. Hence, we have to check the target method name can not be the same as the existing method.

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m(int a) {	
  }

  void n(int b) {	
  }	
}
 
\end{lstlisting}
\centering{(a) Before}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void n(int a) {	
  }

  void n(int b) {	
  }	
}

\end{lstlisting}
\centering{(b) After}
\end{minipage}
\caption{\textbf{RmR from m to n}}
\label{fig:RmR}
\end{figure}

To further define the duplicate methods, few use-cases are as follows:

\subsubsection {Duplicate Methods with convertible Input parameters}

From Fig. \ref{fig:RmR4}, method m1 has input parameter type as `int' and m2 has input parameter type as `double'. When we call method m2 with int data type as the parameter, m2 internally typecasts the passed int into double and outputs `bye' as shown in Fig. \ref{fig:RmR4}(a). 

When we apply RmR from m2 to m1 and call method m1 by passing `int' as input parameter then the output is `hello' as shown in Fig. \ref{fig:RmR4}(b). Here, it is clearly evident that after RmR, the functionality and output has changed even with pre-checking condition for duplicate method. 	
This implies that the definition for duplicate method is not precise and we need to revise duplicate methods to prevent these ambiguity.

In Java we have type conversion of a smaller type to a larger type size automatically.
\textbf{
\begin{center}
byte < short < int < float < double
\end{center}
}

When the duplicate methods have the larger type size and smaller type is passed then it can be converted to larger type size. The revised definition is that the duplicate methods can have the different data type but the property of Widening or Automatic Type Conversion has to be taken care of.

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.7\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m1(int i) {	
    System.out.print("hello");
  }

  void m2(double j) {	
     System.out.print("bye");
  }	
  
  void main(String[] args){
     this.m2(100); // Outputs bye
  }
}
 
\end{lstlisting}
\centering{(a) Before RmR}
\end{minipage}
\hfill
\begin{minipage}[t]{0.7\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m1(int i) {	
    System.out.print("hello");
  }

  void m1(double j) {	
     System.out.print("bye");
  }	
  
  void main(String[] args){
     this.m1(100); // Outputs hello
  }
}

\end{lstlisting}
\centering{(b) After RmR from m2 to m1}
\end{minipage}
\caption{\textbf{Duplicate Methods with convertible input parameter}}
\label{fig:RmR4}
\end{figure}

\subsubsection {Non-Duplicate methods Ambiguity} 
From Fig. \ref{fig:RmR5}(a), methods m1 and m2 are non-duplicate methods and the output is `hello'. However, when we apply RmR from m2 to m1 as shown in Fig. \ref{fig:RmR5}(b), the compiler produces an error \textsl{``reference to m1 is ambiguous as both method m1(String,double) in A and method m1(Object,int) in A match''}. 

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.8\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A{

   void m1(String s, double d){
      System.out.print(s); // Outputs hello
   }

   void m2(Object o, int i){
      System.out.print(o);
   }

   void main(String[] args){
      this.m1("hello", 1);
   }
}
\end{lstlisting}
\centering{(a) Before RmR}
\end{minipage}
\hfill
\begin{minipage}[t]{0.8\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A{

   void m1(String s, double d){
      System.out.print(s); // Error
   }

   void m1(Object o, int i){
      System.out.print(o);
   }

   void main(String[] args){
      this.m1("hello", 1);
   }
}

\end{lstlisting}
\centering{(b) After RmR from m2 to m1}
\end{minipage}
\caption{\textbf{Arguement Ambiguity}}
\label{fig:RmR5}
\end{figure}

Hence, it is essential to pre-check that the non-duplicate methods on RmR does not result in argument ambiguity.

\subsection{A duplicate method in a child class cannot have different return type.}

If a duplicate method exists in both parent and child class, Java does not allow these duplicate methods to have different return types.

In Fig. \ref{fig:RmR2} (b), when we apply RmR from B.m2() to B.m1(), compiler produces an error \textsl{`` m1() in B cannot override m1() in A as return type int is not compatible with void''}. This is because the duplicate method m1 have different return types which is not allowed. 

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.7\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m1() {
    System.out.print("hello");
  }
}
class B extends A{
 
  int m2() {
    System.out.print("bye");
  }	
}
 
\end{lstlisting}
\centering{(a) Before}
\end{minipage}
\hfill
\begin{minipage}[t]{0.7\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m1() {
    System.out.print ("hello");
  }
}
class B extends A{
 
  int m1() {
    System.out.print ("bye");
  }	
}

\end{lstlisting}
\centering{(b) After}
\end{minipage}
\caption{\textbf{RmR from m2 to m}}
\label{fig:RmR2}
\end{figure}

\subsection{A duplicate method in a child class cannot reduce visibility.}

The use of access modifiers helps with visible duplicate methods, however there is a proper hierarchy for access modifiers to be followed for duplicate methods.


\begin{center}
\textbf{public $>$ protected $>$ package-public $>$ private}
\end{center}


As shown in \ref{fig:RmR3}(b), the package-public visibility gets reduced to private for duplicate methods m1() and compiler produces an error \textsl{``m1() in B cannot override m1() in A as attempting to assign weaker access privileges; was package''}. 

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.7\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m1() {
    System.out.print ("hello");
  }
}
class B extends A{

  private void m2() {
    System.out.print ("bye");
  }	
}
 
\end{lstlisting}
\centering{(a) Before RmR}
\end{minipage}
\hfill
\begin{minipage}[t]{0.7\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m1() {
    System.out.print ("hello");
  }
}
class B extends A{
 
  private void m1() {
    System.out.print ("bye");
  }	
}

\end{lstlisting}
\centering{(b) After RmR from m2 to m1}
\end{minipage}
\caption{\textbf{Duplicate methods with reduced visibility}}
\label{fig:RmR3}
\end{figure}

Therefore, it is essential to pre-check that new name of method does not result in visibility reduction. 