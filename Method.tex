\section{\textbf{Preconditions of Rename Method Refactoring}}

Rename Method Refactoring (RmR) changes the name of the method and all references to that method to the new name without changing its functionality in the program.

There are three types of Rename Method Refactorings:
\begin{enumerate}
\item Rename Static Method Declarations.
\item Rename Non-static Method Declarations.
\item Rename Constructor Method Declarations.
\end{enumerate}

There are certain preconditions required for RmR which are applicable to each type of RmR.
\begin{enumerate}
	\item The target method cannot be a duplicate of an existing method after rename.
	\item A duplicate method in a child class cannot have different return type.
	\item A duplicate method in a child class cannot reduce visibility.
\end{enumerate}

\subsection {The target method can not be duplicate of an existing method after rename. }

If we use the same name of an existing method for RmR like Fig. \ref{fig:RmR}, the compiler will show the error: \textsl{method n() is already defined in class A.}

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m(int a) {	
  }

  void n(int b) {	
  }	
}
 
\end{lstlisting}
\centering{(a) Before RmR}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void n(int a) {	
  }

  void n(int b) {	
  }	
}

\end{lstlisting}
\centering{(b) After RmR}
\end{minipage}
\caption{\textbf{Example of RmR}}
\label{fig:RmR}
\end{figure}

To understand the above precondition, we should know what exactly is duplicate method.

By Definition of duplicate method, there are following properties:
1) The method should have same name.
2) Same Parameter types in order
3) Same number of function parameters

For example like Fig. \ref{fig:RmR}, there are method \textsl{m} and method \textsl{n} with same input parameters but different method names. If we do RmR for m to n, the compiler will show the error: \textsl{method n() is already defined in class A.} The behavior of the code does not remain the same after doing RmR. Hence, we have to check the target method name can not be the same as the existing method.

\subsection{A duplicate method in a child class cannot have different return type.}

Java does not allow methods with the same signature to have different return types.

In Fig. \ref{fig:RmR2} (a), A.m1() and B.m2() are two non-duplicate methods which can be rename refactored. However, in Fig. \ref{fig:RmR2} (b), after doing RmR from B.m2() to B.m1(), we get compile-error because the duplicate method m1 have different return types which is not allowed. Thus, we need to check this precondition before doing RmR to avoid compile errors.

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m1() {
		System.out.print ("Hello");
  }
}
class B extends A{
 
	int m2() {
		System.out.print ("Bye");
  }	
}
 
\end{lstlisting}
\centering{(a) Before RmR}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
cclass A {

  void m1() {
		System.out.print ("Hello");
  }
}
class B extends A{
 
	int m1() {
		System.out.print ("Bye");
  }	
}

\end{lstlisting}
\centering{(b) After RmR}
\end{minipage}
\caption{\textbf{Example of RmR to duplicate methods with different return types}}
\label{fig:RmR2}
\end{figure}

\subsection{A duplicate method in a child class cannot reduce visibility.}

The use of access modifiers helps with visible duplicate methods, however, there is a proper hierarchy for access modifiers to be followed for duplicate methods.

\textbf{public} > \textbf{protected} > \textbf{package-public} > \textbf{private}

As shown in \ref{fig:RmR3} (b), the package-public visibility can not be reduced to private for duplicate methods m1(). We also need to chech this precondition before doing RmR to the duplicate methods.

\begin{figure}[th]
\centering
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
class A {

  void m1() {
		System.out.print ("Hello");
  }
}
class B extends A{
 
	private void m2() {
		System.out.print ("Bye");
  }	
}
 
\end{lstlisting}
\centering{(a) Before RmR}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=java, basicstyle=\scriptsize\ttfamily,frame=single]
cclass A {

  void m1() {
		System.out.print ("Hello");
  }
}
class B extends A{
 
	private void m1() {
		System.out.print ("Bye");
  }	
}

\end{lstlisting}
\centering{(b) After RmR}
\end{minipage}
\caption{\textbf{Example of RmR to duplicate methods with reduced visibility}}
\label{fig:RmR3}
\end{figure}